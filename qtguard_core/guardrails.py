from __future__ import annotations

import re
from typing import List, Tuple

from qtguard_core.schema import QTGuardOutput

# Required inputs for a minimally safe QT triage (demo guardrails)
_REQUIRED_PATTERNS: List[Tuple[str, re.Pattern]] = [
    ("QTc", re.compile(r"\bqtc\b|\bqt\s*c\b|\bqt interval\b", re.IGNORECASE)),
    # Looks for explicit lab notation like K=3.1 or Mg:1.6, while still accepting full words.
    ("Potassium (K)", re.compile(r"\bpotassium\b|\bK\s*[:=]\s*\d", re.IGNORECASE)),
    ("Magnesium (Mg)", re.compile(r"\bmagnesium\b|\bMg\s*[:=]\s*\d", re.IGNORECASE)),
]

# Optional but helpful (kept for future extension)
_OPTIONAL_PATTERNS: List[Tuple[str, re.Pattern]] = [
    ("Heart rate (HR)", re.compile(r"\bHR\b|\bheart rate\b", re.IGNORECASE)),
]

# Values that should be treated as "missing" even if the label exists
_MISSING_VALUE_TOKENS = {"unknown", "n/a", "na", "none", "null", "pending", "tbd"}


def _has_missing_value_for(label: str, text: str) -> bool:
    """
    Detect cases like:
      QTc=unknown, QTc: pending, Potassium: n/a, Mg=NA
    Even if the label is present, the value is not usable.
    """
    if not text:
        return True

    # Normalize whitespace for more stable matching
    t = re.sub(r"\s+", " ", text).strip()

    if label == "QTc":
        # Matches "QTc=unknown", "QTc : pending", "QT interval = n/a", etc.
        return bool(re.search(
            r"(qtc|qt\s*c|qt interval)\s*[:=]\s*("
            + "|".join(map(re.escape, _MISSING_VALUE_TOKENS)) +
            r")\b",
            t,
            flags=re.IGNORECASE,
        ))

    if label == "Potassium (K)":
        return bool(re.search(
            r"(potassium|\bK)\s*[:=]\s*("
            + "|".join(map(re.escape, _MISSING_VALUE_TOKENS)) +
            r")\b",
            t,
            flags=re.IGNORECASE,
        ))

    if label == "Magnesium (Mg)":
        return bool(re.search(
            r"(magnesium|\bMg)\s*[:=]\s*("
            + "|".join(map(re.escape, _MISSING_VALUE_TOKENS)) +
            r")\b",
            t,
            flags=re.IGNORECASE,
        ))

    return False


def find_missing_inputs(mini_chart: str) -> List[str]:
    """
    Missing-data detector for the demo scaffold.

    Rules:
    - Required label absent -> missing
    - Label present BUT value is explicitly unknown/pending/n/a -> missing
    """
    text = mini_chart or ""
    missing: List[str] = []

    for label, pattern in _REQUIRED_PATTERNS:
        if not pattern.search(text):
            missing.append(label)
            continue
        # Label exists; ensure the value isn't explicitly unknown/pending/etc.
        if _has_missing_value_for(label, text):
            missing.append(label)

    return missing


def build_safe_output(mini_chart: str) -> QTGuardOutput:
    """
    If missing required fields, return a deferral output.
    Otherwise call MedGemma (HAI-DEF) to generate a structured plan.
    """
    missing = find_missing_inputs(mini_chart)
    if missing:
        out = QTGuardOutput.deferral(missing)
        # Ensure audit notes are internally consistent
        try:
            out.audit_view.notes.append(f"Guardrails: missing required inputs: {', '.join(missing)}.")
        except Exception:
            pass
        return out

    # Inputs present -> call MedGemma
    try:
        from qtguard_core.inference import generate_qtguard_output

        out = generate_qtguard_output(mini_chart)
        out.audit_view.notes.append("Generated by MedGemma (HAI-DEF) with JSON schema validation.")
        return out

    except Exception as e:
        # Safe fallback if inference fails
        fallback = QTGuardOutput(
            risk_summary="Inputs appear present, but model inference failed. Returning safe placeholder output.",
            action_plan=[
                "Re-run the generation. If the issue persists, confirm model access/terms and hardware capacity.",
                "Do not make medication changes based solely on this tool output.",
            ],
            patient_counseling=(
                "This tool could not generate guidance at this time. Please ask your care team to review the case."
            ),
            audit_view={
                "missing_data": [],  # inputs were present by our guardrails check
                "notes": [
                    "Guardrails check passed for required inputs (QTc, K, Mg).",
                    f"MedGemma inference error: {type(e).__name__}: {e}",
                ],
            },
        )
        return fallback
